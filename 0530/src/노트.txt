프로세서
=> 실행중에 프로그램을 말함
멀티프로세서
=> 동시에 여러 프로그램이 실행

쓰레드
=> 프로그램 안에서 실행중에 메서드를 말함
멀티 쓰레드
=> 프로그램 안에서 여러개의 메서드가 동시다발로 동작하는 것을 말함

자바에서는 멀티쓰레드 프로그래밍을 위하여
Thread 클래스와 Runnable 인터페이스를 이용할 수 있음

Thread 가 해야 하는 일은 run() 메서드를 오버라이딩해서 그 안에 써주고
Thread 를 동작시키기 위해서는 start() 메서드를 호출함

---------------------------------------------------------------------------------------------
쓰레드를 가동시키기 위해서 start() 메서드를 호출해야 하는데 run()을 호출하면 오류가 난다?
-> 오류x 쓰레드를 가동시키는 것이 아니고 일반 메서드 처럼 동작함

---------------------------------------------------------------------------------------------
class Hello implements Runnable{
    public void run(){
        ...
    }
}
위의 객체를 생성하고 쓰레드를 가동시키는 명령어
Hello hello = new Hello();
new Thread(hello).start();
==> Runnable 인터페이스를 구현한 객체는 직접 start를 호출 할 수 없어 Thread를 통해서 start를 호출해야 함

<<쓰레드의 우선순위 설정>>
필요하다면 쓰레드의 우선순위를 설정할 수 있음
가급적 다른것들 보다 더 빨리 작업을 완료해 달라고 요청하는 것이지
요청했다고 반드시 더 빨리 작업이 완료되는것이 보장되지는 않음
setPriority(new Priority);

new Priority의 범위
1 => Thread.MIN_PRIORITY
5 => Thread.NORM_PRIORITY
10 => Thread.MAX_PRIORITY
--------------------------------------------------------------------------------------------------
a = new Person("홍길동");
b = new Person("이순신");
b에 최고우선순위를 설정
b.setPriority(MAX_PRIORITY);
----------------------------------------------------------------------------------------------------
class Person extends Thread{
    private String name;
    public Person(String name){
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i <5 ; i++) {
            System.out.println(name+"이 밥을 먹어요 ==> "+(i+1));
            try{
                Thread.sleep(50);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}

public class PersonTest {
    public static void main(String[] args) {
        Person p = new Person("P");
        Person p1 = new Person("P1");
        Person p2 = new Person("P2");

        p.setPriority(Thread.NORM_PRIORITY);
        p1.setPriority(Thread.MIN_PRIORITY);
        p2.setPriority(Thread.MAX_PRIORITY);

        p.start();
        p1.start();
        p2.start();
    }
}
// 실행 결과
P2이 밥을 먹어요 ==> 1                    P2이 밥을 먹어요 ==> 3
P이 밥을 먹어요 ==> 1                     P이 밥을 먹어요 ==> 3
P1이 밥을 먹어요 ==> 1                    P1이 밥을 먹어요 ==> 3
P2이 밥을 먹어요 ==> 2                    P이 밥을 먹어요 ==> 4
P1이 밥을 먹어요 ==> 2                    P2이 밥을 먹어요 ==> 4
P이 밥을 먹어요 ==> 2                     P1이 밥을 먹어요 ==> 4
                                        P이 밥을 먹어요 ==> 5
                                        P2이 밥을 먹어요 ==> 5
                                        P1이 밥을 먹어요 ==> 5

<< 임계영역 (Critical Section) >>
두 개이상의 쓰레드가 자원을 공유할 때에
한번에 하나의 쓰레드에게만 접근을 허용하는 영역을 말하며
자바에서는 그러한 동작을 하는 메서드이름 앞에 혹은 블럭( {} ) 앞에
synchronized 키워드를 붙이면 자동으로 임계영역이 되면 한번에 하나의 쓰레드에게만 접근을 허용하게 됨

쓰레드를 가동 시키면 가능하면 동시다발로 공평하게 실행이 되게끔 스케쥴링을 해 줌
만약에 두개의 객체가 반드시 1:1로 동작하도록 하려면 쓰레드 사이의 통신을 이용할 수 있음

<< 쓰레드 사이의 통신 >>
두개의 쓰레드가 반드시 1:1로 동작하도록 하려면 쓰레드 상의 통신이 필요함
작업을 하고 있는 동안 대기 -> 작업이 끝났으니 작업하라 지시 ->
와 같이 쓰레드 사이의 통신을 이용하면 1:1로 동작하도록 만들 수 있음

예를들어 "생산자"와 "소비자"가 있다고 할 때
새로운 제품이 생산되어야지만 소비가 일어나고 소비가 일어나야지만 새로운 제품을 생산하는 경우에는
둘 사이에 생산이 되었는지 소비가 있었는지 서로 통신이 필요함
생산자는 소비가 일어날 때 까지 기다렸다가 소비가 되면 새로운 제품을 생산하고 소비자는
생산이 일어날 때 까지 기다렸다가 새로운 제품이 생산되면 소비가 일어나도록
반드시 1:1로 동작하도록 할 수 있음

자바에서는 이러한 쓰레드 사이의 통신을 위하여 자바의 제일 조상클래스인
Object의 wait와 notify 메서드를 이용함

상대방이 작업이 완료될때까지 기다리게 하기 위해서는 wait 메서드를 이용하고
내가 일이 끝나서 상대방을 깨울 때는 notify 메서드를 이용함


CUI : Character User Interface
	=> 사용자와 컴퓨터가 문자로 의사소통 하는 환경을 말한다.

GUI : Graphic User Interface
	=> 사용자와 컴퓨터가 그래픽요소로 의사소통 하는 것을 말한다.

자바는 GUI를 위한 awt 패키지와 swing 패키지를 만들어 둠
JFrame  : 창
JButton : 버튼
JTextFeiled : 한줄 글자 입력
JTextArea   : 여러줄 글자 입력
JLavel

배치관리자(LayoutManager)
화면 구성요소들을 배치하는 관리자
- FlowLayout
    => 화면구성 요소들을 왼쪽에서 오른쪽으로 위에서 아래로 물 흐르듯이 배치하는 관리자
- GridLayout
    => 행, 열로 배치
- BorderLayout
    => 화면을 동,서,남,북, 가운데 5개의 영역으로 분할하여 배치하는 방식
    => 보통 5개의 영역에 모두 배치하기 보다는 가운데를 중심으로 하여 중요한 컨텐츠를 가운데에 놓고
        부가적인 메듀 등을 위,아래, 왼쪽, 오른쪽에 배치하여 사용함.
        즉, 위, 아래, 왼쪽, 오른쪽은 생략하여 사용하고 가운데는 생략하지 않는 것이 일반적