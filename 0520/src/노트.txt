클래스 변수 : 일반적으로 클래스의 맴버 변수들은 객체를 생성해야지만 메모리가 확보되고 반드시
		객체를 통해서 사용할 수 있는데, 객체와 무관하게 사용할 메모리 공간이 필요하거나
		모든 객체가 공동으로 사용할 메모리 공간이 필요하다면 맴버변수명 앞에 static 키워드를
		붙여서 클래스 변수로 만들어서 사용함.
		객체없이 접근해야 하기 때문에 클래스 이름으로 접근

클래스 메서드 : 일반적으로 맴버메서드들은 반드시 객체를 생성하고 그 객체를 통해서 사용 가능
		객체와 무관하게 동작시키고자 하는 기능이 있다면 메서드 이름 앞에 static 키워드를
		사용하여 클래스 메서드로 만들 수 있다.
		객체 없이도 접근해야 하기 때문에 클래스 이름으로 접근

클래스변수와 클래스 메서드는 객체 없이 클래스이름으로 접근할 수 있고, 만약 객체를 생성 했다면
	객체를 통해서도 접근 할 수 있다.


클래스 메서드에서는 반드시 클래스 맴버에만 접근할 수 있다.
객체를 생성해야만 사용할 수 있는 일반 맴버에는 접근할 수 없다.

** 생성자 중복 ( Constructor Overloading )
- 인자가 있는 생성자와 인자가 없는 생성자 등 한 클래스에 여러 생성자를 만들 수 있다.
- 허용 조건은 타입을 다르게 하거나 순서 또는 개수를 다르게 해야 한다.

** 메서드 중복 ( Method Overloading )
=> 같은 이름의 메서드를 중복하여 정의하는 것을 말하며
	매개변수의 개수가 다르거나 순서 또는 자료형이 달라야 함


객체지향 프로그래밍의 특징
	1) 은닉성(Encapsulation)
		접근명시자 : private, public
	
	2) 상속성(Ingeritance)
		이미 정의되어 있는 클래스를 확장하여(상속하여) 새로운 클래스를 만듬
		코드의 재사용성 높힘
		
		==> 상속을 해준 클래스를 "부모 클래스"(상위 클래스)
		==> 상속을 받은 클래스를 "자식 클래스"(하위 클래스)

	class 부모클래스{
	}

	class 자식클래스 extends 부모클래스{
	}
이렇게 함으로써 자식 클래스는 부모 클래스의 모든 속성과 동작을 물려받게 됩니다.
부모 클래스의 코드양이 몇백줄이 된다고 할 때에 extends 부모 클래스 하는 순간
자식 클래스에서 그 코드를 모두 사용 가능
==> 상속을 함으로써 코드의 재사용성을 높힐 수 있다.

현실에서 "동물" 이라는 단어 보다는 "쥐", "말", "토끼", "뱀" 이라는 단어를 먼저 사용
"쥐", "말", "토끼", "뱀" 등이 공통으로 가지는 속성과 동작을 뽑아서
일반화 하여 "동물" 이라고 정의 했을 것으로 추측

이와 같이 우리 미래에 만들어질 클래스들의 공통적인 속성과 동작을 뽑아서
"일반화" 하는 것도 "상속"이라고 할 수 있습니다.

"쥐" 는 "동물"이다,
"말" 은 "동물"이다 라고 표현할 수 있듯이

상속관계는 is a 관계가 성립되어야 함

        // 아무리 상속받은 자식 클래스라 해도
        // 부모클래스의 private 영역에는 접근할 수 없다.
        // protected 를 사용하면 자식클래스에서 사용 가능


default 접근명시자
	접근명시자를 생략한 상태를 말함
	동일한 패키지에 있는 클래스들에게는 접근을 허용함

// 접근명시자를 생략하면 dafault 접근명시자로써 동일한 패키지에 있는 클래스들에게만 접근 허용
// 아무리 상속받은 자식이라 하더라도 동일한 패키지에 있지 않으면 접근 할 수 없다.



접근명시자
private   	 : 클래스 자신만 접근할 수 있고 외부의 모든 클래스로부터 접근을 허용하지 않음
public	 : 외부의 어떤 클래스라도 접근 가능
protected : 외부의 다른 클래스로부터는 보호하고, 상속된 자식클래스들에게는 접근 허용
dafault 	 : 외부의 다른 클래스로부터는 보호하고, 동일한 패키지에 있는 클래스들에게는 접근 허용

메서드 오버로딩( Method Overloading )  :
	같은 이름의 메서드를 중복하여 정의하는 것을 말하며
	매개변수의 개수나 순서, 자료형(타입)이 달라야 함

메서드 오버라이딩( Method Overriding ) :
	상속관계에 있을 때 부모의 동일한 이름의 메서드를
	자식클래스에 맞도록 다시정의(재정의)하는 것을 말하며,
	메서드 이름뿐 아니라 매개변수의 개수와 자료형 까지 일치되어야 함

super();
상속관계에 있을 때 부모 클래스의 생성자를 동작시키는 키워드.
반드시 생성자의 첫 번째 문장에 와야 합니다.

super.맴버변수
super.맴버메서드()
상속관계에 있을 때 부모 클래스의 맴버와 동일한 이름의 맴버를 자식 클래스에 만들면
부모에 있는 동일한 맴버는 가려지게 되어 자식에서 만든 맴버가 우선순위가 높음
만약 부모클래스에 있는 동일한 이름의 맴버에 접근하려면 super 키워드를 통해서 접근 가능

상속과 생성자
=> 상속관계에 있을 때 자식의 객체를 생성하면 별다른 문장이 없어도 부모의 생성자가
	먼저 동작하고 자식의 생성자가 동작함
	만약 부모의 매개변수를 갖는 생성자를 동작시키려면 super([값]) 를 사용해야 함


class A{

}
class B extends A}
}

위의 경우에 B ob = new B() 처럼 객체를 생성하면
부모클래스인 A의 기본생성자가 먼저 동작하고 B의 기본 생성자가 동작함

자바는 따로 생성자를 만들지 않으면 기본 생성자를 실행

class A{
	public A(int data){
	}
}
class B extends A}
}

위와 같은 경우에는
B ob = new B()라고 하면 오류가 발생
A클래스에서 매개변수를 갖는 생성자를 사용자가 만들었기 때문에 기본생성자 생성하지 않음
근데 B ob = new B()의 경우는 부모의 기본생성자를 요구하기 때문에 오류가 발생함

객체지향 프로그래밍의 특징
1) 은닉성
2) 상속성
3) 다형성(polymorphism)
	객체마다 받은 메시지는 동일한데 객체마다 동작하는 방식이 다름
	상속관계에 있을 때 부모로 부터 물려받은 메서드를 자신에게 맞도록
	재정의 한 경우에 자식클래스의 객체마다 동작하는 방식이 다르다
	이것을 "다형성"이라고 함

        SalariedEmployee e1 = new SalariedEmployee("A", "A0001", 1);
        HourlyEmployee h1 = new HourlyEmployee("C", "H0001", 10000, 20);

        e1.computeSalary();
        h1.computeSalary();

위의 실습코드에서 A,B 에서 모두 동일한 메시지 computeSalary를 주었는데
e1 은 호봉에 따라 기본급, 수당을 결정하고 기본금과 수당을 더해서 급여를 계산함
그러나 h1을 시간당 임금과 일한 시간을 곱하기 하여 실수령액을 계산
이와 같이 두개의 객체가 동일한 메시지를 받았는데 동작하는 방식, 응답이 다름
=> 다형성


        Rectangle r1 = new Rectangle(10,10,5.5,7.5);
        Circle c1 = new Circle(30, 30, 5);
        Shape r2 = new Rectangle(10,10,5.5,7.5);
        Shape c2 = new Circle(30, 30, 5);

위의 코드에서 Shape은 Rectangle과 Circle의 부모 클래스
부모클래스의 참조변수는 자식 클래스의 객체를 참조할 수 있다.

2차원 도형이 많이 필요하다 하면 배열을 이용 하면 되는데
2차원 도형에는 다양한 도형이 있어 타입을 각각 지정해서 생성하면 낭비
이럴 때 도형을 모두 담을 수 있는 상위클래스 타입으로 배열을 만들면 됨



추상 클래스와 추상 메서드
미래에 만들어질 자식클래스들이 가져야할 공통적인 속성과 동작을 뽑아서
일반화할 때(부모클래스 만들때에) 반드시 자식클래스가 가져야할 메서드
바디를 구체화 할 수 없는 메서드는 추상 메서드로 만듬
메서드 이름 앞에 abstract 을 붙여 추상메서드 임을 표시
추상 메서드를 1개라도 가지고 있는 클래스를 추상 클래스라고함 

어떠한 클래스가 반드시 하위 클래스가 필요하고 자식 클래스들에게 맞도록 재정의 해야 하는 메서드가
있을 때 상위 클래스를 만드는 시점에서는 그 메서드의 바디를 구체화 할 수 없을 때
메서드 선언만 함 => 이와 같이 메서드 바디가 없고 선언부만 있는 메서드를 추상메서드라고 함
메서드 앞에 abstract 키워드를 붙여 줘야함

이와 같이 어떠한 클래스가 추상메서드를 하나라도 가지고 있다면 그 클래스 자신이 추상 클래스가
되어야 하며 class 앞에 abstract 키워드를 붙여야 함

어떠한 클래스가 추상 클래스로 부터 상속받았다면
반드시 그 추상 클래스 안에 있는 모든 추상메서드를 오버라이딩 해야 함
일반적으로 상속관계에 있을때 하위 클래스는 상위 클래스의 메서드가 마음에 들면 그대로 사용하고
자신에게 맞지 않으면 선택적으로 메서드를 재정의(오버라이딩) 할 수 있다.
하위 클래스들에게 어떤 메서드를 반드시 오버라이딩 하고자 한다면 그 메서드를 추상 메서드로 만듦


추상 클래스는 바디가 구체화되지 않는 메서드를 가지고 있기 때문에 추상 클래스의 객체는 생성 불가하지만
추상 클래스의 참조 변수가 추상메서드를 오버라이딩 한 하위 클래스의 객체는 생성할 수 있다(참조가능)

추상클래스는 구체화된 메서드도 가질 수 있음


부모의 참조변수가 자식의 객체를 생성할 수 있다.
그러나 자식에서 새로 추가된 메서드를 호출할 수 없다.
호출하려면 자식클래스로 캐스팅 해야 함
class A{
}
class B extends A{
	public void pro(){
	}
}
A ob = new B();
ob.pro(); 	<= 안됨 // pro() 는 B에만 있음
((B) ob).pro(); 	// 캐스팅하여 호출

class C extends A{
	public hello(){
	}
}

A[] data = new A[];
배열의 자료형이 A이기 때문에
data 배열에는 A의 하위인 B, C의 자료형을 모두 담을 수 있음
배열의 요소만큼 반복실행하여 만약 그 배열의 요소가 B의 자료형이라면 B 클래스에 추가된 pro를 동작시키고
그렇지 않으면 C클래스 추가된 hello를 동작시켜야 한다면
해당 클래스의 객체인지 물어봐서 해당 클래스로 형변환 해야 합니다.
이 때 해당 클래스의 객체인지 판별하기 위한 연산자는 instanceof
for( A ob : data){
	if(ob instanceof B){
		((B)ob).pro();
	} else{
		((C)ob).hello();
	}
	
}

instanceof
==> 상속관계에 있을 때 상위의 참조변수가 자식의 객체를 참조할 수 있음
	많은 양의 데이터를 처리 하기 위하여 배열을 이용하는데 부모의 참조자료형으로 배열을 만들면
	여러 종류의 하위 클래스의 객체를 담을 수 있음
	그러나 해당 하위 클래스에서 추가된 메서드를 바로 호출 할 수는 없어서
	해당 자식클래스로 형변환해야 하는데 이때 어떤 하위클래스인지 판별할 때에
	instanceof 사용

==> instanceof (객체 타입 확인 연산자)
for (int i = 0; i < n; i++) {
            Shape s = shapes[i];
            if (s instanceof TwoDimShape){
                ((TwoDimShape) s).calcArea();
            }else {
                ((ThreeDimShape) s).calcVolume();
            }
            System.out.println(s);
        }
2차원 도형도 담고, 3차원도형도 담기 위하여
shapes 배열의 자료형을 2차원 도형과 3차원 도형 클래스의 상위 클래스인 Shape 로 만듦
배열의 요소를 출력하여 그것이 2차원 도형 클래스라면 2차원 도형 클래스로
캐스팅하고 면적을 계산시키는 메서드를 호출
만약 3차원 도형이라면 3차원 도형 클래스로 캐스팅하고 부피를 계산시키는 메서드를 호출



** 클래스 변수와 클래스 메서드에 대해 설명
- static 키워드로 생성
- 객체를 생성하지 않고도 접근할 수 있음
- 객체를 생성할 때마다 초기화, 생성되지 않음
- 모든 객체가 공동으로 가짐

public String name은 객체마다 1개씩 가지고 있고, 객체를 생성할 때 초기화, 생성됨
public static String name은 모든 객체가 공동으로 가지고 있고, 객체를 생성하지 않고도 접근 가능 


** abstract 키워드에 대해 설명
- 하위 클래스에서 다른 결과값 필요할 때 상위 클래스에서 정의
- 하위 클래스에서 반드시 재정의를 해야함
- 1개이상의 추상 메서드가 있으면 클래스도 추상 클래스로 변경






















